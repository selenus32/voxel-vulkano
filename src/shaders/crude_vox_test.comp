#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D img;
layout(set = 0, binding = 1) uniform CameraMats {
    mat4 view;
    mat4 proj;
    vec2 _padding[8];
} cam;

vec3 lightDir = vec3(2,20,-50);

vec3 lighting(vec3 norm, vec3 pos, vec3 rd, vec3 col) {
    lightDir = normalize(lightDir);
    float diffuseAttn = max(dot(norm, lightDir), 0.0);
    vec3 light = vec3(1.,1.0,1.0);
    
    vec3 ambient = vec3(0.1, 0.1, 0.1);
    
    vec3 reflected = reflect(rd, norm);
    float specularAttn = max(dot(reflected, lightDir), 0.0);
    
    return col*(diffuseAttn*light*1.0 + specularAttn*light*0.6 + ambient);
}

struct hit {
    bool didHit;
    vec3 col;
};

struct Ray {
    vec3 origin;
    vec3 dir;
};

float de( vec3 pos ) {
    #define SCALE 2.8
    #define MINRAD2 .25
    #define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)
    float minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);
    float absScalem1 = abs(SCALE - 1.0);
    float AbsScale = pow(abs(SCALE), float(1-10));
    vec4 p = vec4(pos,1);
    vec4 p0 = p;
    for (int i = 0; i < 2; i++)
    {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
        float r2 = dot(p.xyz, p.xyz);
        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);
        p = p*scale + p0;
    }
    return ((length(p.xyz) - absScalem1) / p.w - AbsScale);
}

hit getBoxel(ivec3 p) {
    if (float(p.x)*500. < 0.2)
    	return hit(true, vec3(p) / 50 + 0.);
    else
        return hit(false, vec3(0,0,0));
}

hit getVoxel(ivec3 p) {
	float frequency = 0.05;
	float amplitude = 3.;
	
	float noise = de(p*0.1)-1.;
	float xOffset = amplitude*sin(p.x * frequency)*noise;
	float zOffset = amplitude*sin(p.z * frequency);
    //zOffset *= noise*amplitude;

	float surfaceY = 50 + xOffset + zOffset;

	float sizePlane = 60;
	//float maxHeight = 50;
	float minHeight = 0;
	return (p.y < surfaceY && p.y > minHeight) ? hit(true, p/100.) : hit(false,vec3(0.));
}

hit intersect(Ray ray) {
    vec3 pos = floor(ray.origin);

    //by amanatides/woo http://www.cse.yorku.ca/~amana/research/grid.pdf
    vec3 tMax;

    vec3 fr = fract(ray.origin);
    vec3 step = vec3(sign(ray.dir));
    vec3 tDelta = step / ray.dir;

    tMax.x = tDelta.x * ((ray.dir.x>0.0) ? (1.0 - fr.x) : fr.x);
    tMax.y = tDelta.y * ((ray.dir.y>0.0) ? (1.0 - fr.y) : fr.y);
    tMax.z = tDelta.z * ((ray.dir.z>0.0) ? (1.0 - fr.z) : fr.z);

    vec3 norm;
    const int maxTrace = 500;
	
    bvec3 mask;

    for (int i = 0; i < maxTrace; i++) {
        hit h = getVoxel(ivec3(pos));
        if (h.didHit) {
            return hit(true, lighting(norm, pos, ray.dir, h.col));
        }
        if (tMax.x < tMax.y) {
            if (tMax.z < tMax.x) {
                tMax.z += tDelta.z;
                pos.z += step.z;
                norm = vec3(0, 0,-step.z);
            } else {
                tMax.x += tDelta.x;
                pos.x += step.x;
                norm = vec3(-step.x, 0, 0);
            }
        } else {
            if (tMax.z < tMax.y) {
                tMax.z += tDelta.z;
                pos.z += step.z;
                norm = vec3(0, 0, -step.z);
            } else {
                tMax.y += tDelta.y;
                pos.y += step.y;
                norm = vec3(0, -step.y, 0);
            }
        }
    }
 	return hit(false, vec3(0,0,0));
}

void main() {
    ivec2 img_coord = ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y);
    vec2 uv = vec2(img_coord-0.5) / imageSize(img).xy;
    
    mat4 view = inverse(cam.view);
    mat4 proj = cam.proj;
    mat4 clip_to_world = transpose(inverse(view*proj));
    float proj_fov = -(3.141/180)*4*atan(proj[1][1]);
    vec4 clip_space_coord = vec4((uv.x - 0.5), - (uv.y - 0.5), 0.0, proj_fov);

    //vec3 ray_origin = view[3].xyz;
    vec3 ray_origin = vec3(view[3][0],view[3][1],view[3][2]);
    vec3 ray_dir = (clip_to_world*clip_space_coord).xyz;

    Ray ray = Ray(ray_origin,ray_dir);

    vec4 pixel = vec4(0.);
    hit h = intersect(ray);
    if (h.didHit) {
        pixel = vec4(h.col,0.);
    } else {
        pixel = vec4(0.,0.,0.,0.);
    }

    imageStore(img,  img_coord, pixel);
}